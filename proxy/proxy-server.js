/// –ü—Ä–æ—Å—Ç–æ–π –ø—Ä–æ–∫—Å–∏-—Å–µ—Ä–≤–µ—Ä –¥–ª—è –≤–µ–±-–≤–µ—Ä—Å–∏–∏ Flutter –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
/// 
/// –≠—Ç–æ—Ç —Å–µ—Ä–≤–µ—Ä –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –∑–∞–ø—Ä–æ—Å—ã –æ—Ç –≤–µ–±-–ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –∏ –ø—Ä–æ–∫—Å–∏—Ä—É–µ—Ç –∏—Ö
/// —á–µ—Ä–µ–∑ —É–∫–∞–∑–∞–Ω–Ω—ã–π SOCKS5 –ø—Ä–æ–∫—Å–∏ –∫ API —Å–µ—Ä–≤–∏—Å–∞–º.

const express = require('express');
const { SocksProxyAgent } = require('socks-proxy-agent');
const fetch = require('node-fetch');
const cors = require('cors');

const app = express();
const PORT = 3001;

// Middleware with enhanced mobile support
app.use(cors({
  origin: true, // Allow all origins for mobile compatibility
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With', 'X-Proxy-URL', 'X-Proxy-Host', 'X-Proxy-Port', 'X-Proxy-User', 'X-Proxy-Pass'],
  exposedHeaders: ['Content-Length', 'Content-Type', 'X-Response-Time'],
  maxAge: 86400 // 24 hours cache for preflight requests
}));

// Enhanced JSON parsing with mobile device support
app.use(express.json({ 
  limit: '100mb',
  type: ['application/json', 'text/plain', 'application/x-www-form-urlencoded']
}));

app.use(express.urlencoded({ 
  limit: '100mb', 
  extended: true,
  type: ['application/x-www-form-urlencoded', 'multipart/form-data']
}));

// Mobile-specific headers
app.use((req, res, next) => {
  // Add mobile-friendly headers
  res.header('X-Content-Type-Options', 'nosniff');
  res.header('X-Frame-Options', 'SAMEORIGIN');
  res.header('X-XSS-Protection', '1; mode=block');
  res.header('Cache-Control', 'no-cache, no-store, must-revalidate');
  res.header('Pragma', 'no-cache');
  res.header('Expires', '0');
  
  // Mobile device detection
  const userAgent = req.headers['user-agent'] || '';
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
  
  if (isMobile) {
    console.log(`üì± Mobile device detected: ${userAgent}`);
    // Add mobile-specific optimizations
    res.header('X-Mobile-Optimized', 'true');
  }
  
  next();
});

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø—Ä–æ–∫—Å–∏ –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
const PROXY_URL = process.env.ALL_PROXY || 'socks5h://xexEUhKx:AXySXT2c@45.192.51.104:63435';
const BACKUP_PROXIES = (process.env.BACKUP_PROXIES || '').split(',').filter(p => p.trim());

console.log('üîß Proxy Server Configuration:');
console.log('   Main Proxy:', PROXY_URL);
console.log('   Backup Proxies:', BACKUP_PROXIES.length);

// –°–æ–∑–¥–∞–µ–º –∞–≥–µ–Ω—Ç –¥–ª—è –ø—Ä–æ–∫—Å–∏
let currentProxyAgent = null;
let currentProxyIndex = 0;

function createProxyAgent(proxyUrl) {
  try {
    return new SocksProxyAgent(proxyUrl);
  } catch (error) {
    console.error('‚ùå Error creating proxy agent:', error.message);
    return null;
  }
}

function getCurrentProxyAgent() {
  if (!currentProxyAgent) {
    currentProxyAgent = createProxyAgent(PROXY_URL);
  }
  return currentProxyAgent;
}

function switchToNextProxy() {
  if (BACKUP_PROXIES.length > 0) {
    currentProxyIndex = (currentProxyIndex + 1) % BACKUP_PROXIES.length;
    const nextProxy = BACKUP_PROXIES[currentProxyIndex];
    console.log(`üîÑ Switching to backup proxy: ${nextProxy}`);
    currentProxyAgent = createProxyAgent(nextProxy);
    return currentProxyAgent;
  }
  return null;
}

// –ú–∞—Ä—à—Ä—É—Ç –¥–ª—è –ø—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ OpenAI
app.post('/proxy/openai/*', async (req, res) => {
  try {
    const targetUrl = 'https://api.openai.com' + req.path.replace('/proxy/openai', '');
    
    console.log(`üöÄ Proxying OpenAI request to: ${targetUrl}`);
    console.log(`üì§ Request body:`, JSON.stringify(req.body, null, 2));
    console.log(`üì§ Request headers:`, req.headers);
    
    const agent = getCurrentProxyAgent();
    if (!agent) {
      return res.status(500).json({ error: 'Proxy agent not available' });
    }

    // Enhanced headers for mobile compatibility
    const headers = {
      'Content-Type': 'application/json',
      'Authorization': req.headers.authorization,
      'User-Agent': 'LandComp-AI-Client/1.0',
      'Accept': 'application/json, text/plain, */*',
      'Accept-Language': req.headers['accept-language'] || 'en-US,en;q=0.9',
      'Accept-Encoding': 'gzip, deflate, br',
      'Connection': 'keep-alive',
    };

    // Add mobile-specific headers if detected
    const userAgent = req.headers['user-agent'] || '';
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
    
    if (isMobile) {
      headers['X-Mobile-Client'] = 'true';
      headers['X-Requested-With'] = 'XMLHttpRequest';
    }

    const response = await fetch(targetUrl, {
      method: req.method,
      headers: headers,
      body: JSON.stringify(req.body),
      agent: agent,
      timeout: isMobile ? 180000 : 120000, // Longer timeout for mobile devices
      compress: true, // Enable compression for mobile
    });

    const data = await response.text();
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—Ç–≤–µ—Ç JSON
    try {
      const jsonData = JSON.parse(data);
      res.status(response.status).json(jsonData);
    } catch (e) {
      res.status(response.status).send(data);
    }
    
  } catch (error) {
    console.error('‚ùå OpenAI proxy error:', error.message);
    
    // –ü–æ–ø—Ä–æ–±—É–µ–º –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ —Ä–µ–∑–µ—Ä–≤–Ω—ã–π –ø—Ä–æ–∫—Å–∏
    const backupAgent = switchToNextProxy();
    if (backupAgent) {
      try {
        const targetUrl = 'https://api.openai.com' + req.path.replace('/proxy/openai', '');
        const response = await fetch(targetUrl, {
          method: req.method,
          headers: {
            'Content-Type': 'application/json',
            'Authorization': req.headers.authorization,
            'User-Agent': 'LandComp-AI-Client/1.0',
          },
          body: JSON.stringify(req.body),
          agent: backupAgent,
          timeout: 120000, // 2 minutes for large images
        });

        const data = await response.text();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—Ç–≤–µ—Ç JSON
        try {
          const jsonData = JSON.parse(data);
          res.status(response.status).json(jsonData);
        } catch (e) {
          res.status(response.status).send(data);
        }
        return;
      } catch (backupError) {
        console.error('‚ùå Backup proxy also failed:', backupError.message);
      }
    }
    
    res.status(500).json({ 
      error: 'Proxy request failed', 
      details: error.message 
    });
  }
});

// –ú–∞—Ä—à—Ä—É—Ç –¥–ª—è –ø—Ä–æ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏—è –∑–∞–ø—Ä–æ—Å–æ–≤ –∫ Google Gemini
app.post('/proxy/gemini/*', async (req, res) => {
  try {
    // –°—Ç—Ä–æ–∏–º –ø–æ–ª–Ω—ã–π URL —Å query –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
    const pathWithoutProxy = req.path.replace('/proxy/gemini', '');
    const queryString = req.url.includes('?') ? req.url.substring(req.url.indexOf('?')) : '';
    const targetUrl = 'https://generativelanguage.googleapis.com' + pathWithoutProxy + queryString;
    
    console.log(`üöÄ Proxying Gemini request to: ${targetUrl}`);
    console.log(`üîç Original path: ${req.path}`);
    console.log(`üîç Query params: ${req.query}`);
    console.log(`üîç Full URL: ${req.url}`);
    
    const agent = getCurrentProxyAgent();
    if (!agent) {
      return res.status(500).json({ error: 'Proxy agent not available' });
    }

    // –ò–∑–≤–ª–µ–∫–∞–µ–º API –∫–ª—é—á –∏–∑ URL
    const url = new URL(targetUrl);
    const apiKey = url.searchParams.get('key');
    
    // Enhanced headers for mobile compatibility
    const headers = {
      'Content-Type': 'application/json',
      'User-Agent': 'LandComp-AI-Client/1.0',
      'Accept': 'application/json, text/plain, */*',
      'Accept-Language': req.headers['accept-language'] || 'en-US,en;q=0.9',
      'Accept-Encoding': 'gzip, deflate, br',
      'Connection': 'keep-alive',
    };
    
    // Add mobile-specific headers if detected
    const userAgent = req.headers['user-agent'] || '';
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
    
    if (isMobile) {
      headers['X-Mobile-Client'] = 'true';
      headers['X-Requested-With'] = 'XMLHttpRequest';
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º API –∫–ª—é—á –≤ –∑–∞–≥–æ–ª–æ–≤–∫–∏
    if (apiKey) {
      headers['x-goog-api-key'] = apiKey;
      console.log(`üîë API Key found: ${apiKey.substring(0, 10)}...`);
    } else {
      console.log('‚ö†Ô∏è No API key found in URL');
      console.log(`üîç Full URL: ${targetUrl}`);
    }
    
    // –£–±–∏—Ä–∞–µ–º API –∫–ª—é—á –∏–∑ URL –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    url.searchParams.delete('key');
    const cleanTargetUrl = url.toString();

    const response = await fetch(cleanTargetUrl, {
      method: req.method,
      headers: headers,
      body: JSON.stringify(req.body),
      agent: agent,
      timeout: isMobile ? 180000 : 120000, // Longer timeout for mobile devices
      compress: true, // Enable compression for mobile
    });

    const data = await response.text();
    
    res.status(response.status).json(JSON.parse(data));
    
  } catch (error) {
    console.error('‚ùå Gemini proxy error:', error.message);
    
    // –ü–æ–ø—Ä–æ–±—É–µ–º –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ —Ä–µ–∑–µ—Ä–≤–Ω—ã–π –ø—Ä–æ–∫—Å–∏
    const backupAgent = switchToNextProxy();
    if (backupAgent) {
      try {
        const targetUrl = 'https://generativelanguage.googleapis.com' + req.path.replace('/proxy/gemini', '');
        const url = new URL(targetUrl);
        const apiKey = url.searchParams.get('key');
        
        const headers = {
          'Content-Type': 'application/json',
          'User-Agent': 'LandComp-AI-Client/1.0',
        };
        
        if (apiKey) {
          headers['x-goog-api-key'] = apiKey;
        }
        
        url.searchParams.delete('key');
        const cleanTargetUrl = url.toString();
        
        const response = await fetch(cleanTargetUrl, {
          method: req.method,
          headers: headers,
          body: JSON.stringify(req.body),
          agent: backupAgent,
          timeout: 120000, // 2 minutes for large images
        });

        const data = await response.text();
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—Ç–≤–µ—Ç JSON
        try {
          const jsonData = JSON.parse(data);
          res.status(response.status).json(jsonData);
        } catch (e) {
          res.status(response.status).send(data);
        }
        return;
      } catch (backupError) {
        console.error('‚ùå Backup proxy also failed:', backupError.message);
      }
    }
    
    res.status(500).json({ 
      error: 'Proxy request failed', 
      details: error.message 
    });
  }
});

// –ú–∞—Ä—à—Ä—É—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞ –ø—Ä–æ–∫—Å–∏
app.get('/proxy/status', (req, res) => {
  res.json({
    status: 'running',
    mainProxy: PROXY_URL,
    backupProxies: BACKUP_PROXIES.length,
    currentProxyIndex: currentProxyIndex,
  });
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    proxy: 'running'
  });
});

// Mobile diagnostics endpoint
app.get('/mobile-diagnostics', (req, res) => {
  const userAgent = req.headers['user-agent'] || '';
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
  
  res.json({
    timestamp: new Date().toISOString(),
    device: {
      isMobile,
      userAgent,
      platform: req.headers['sec-ch-ua-platform'] || 'unknown',
      language: req.headers['accept-language'] || 'unknown'
    },
    proxy: {
      status: 'running',
      mainProxy: PROXY_URL,
      backupProxies: BACKUP_PROXIES.length,
      currentProxyIndex: currentProxyIndex
    },
    capabilities: {
      cors: true,
      compression: true,
      mobileOptimized: true,
      extendedTimeout: isMobile
    }
  });
});

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
app.listen(PORT, () => {
  console.log(`üöÄ Proxy server running on http://localhost:${PORT}`);
  console.log(`üì° Ready to proxy requests through: ${PROXY_URL}`);
});

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
});
